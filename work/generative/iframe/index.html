<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
</head>

<body style="margin: 0; overflow: hidden;">
    <a href="https://generative.neef.co" target="_blank" rel="noreferrer noopener" style="width: 100%; height: 100%; position: fixed;"> </a>
    <script src="p5.min.js"> </script>
    <script>

        const sketches = [
            // perlin balls following mouse
            () => {
                let mouseLocation;
                let target;
                let distance;
                let resetMouseLocation;

                let mouseHasMoved = false;
                let lastMouseMovement = 0;

                const balls = [];
                class Ball {
                    constructor(r) {
                        this.xOff = random(200);
                        this.yOff = random(400, 600);
                        this.r = r || 1;
                    }

                    update() {
                        this.xOff += 0.01;
                        this.yOff += 0.01;

                        this.x = mouseLocation.x + map(noise(this.xOff), 0, 1, -width / 2, width / 2);
                        this.y = mouseLocation.y + map(noise(this.yOff), 0, 1, -height / 2, height / 2);

                        ellipse(this.x, this.y, this.r);
                        if (this.r < 36) this.r++;
                    }

                    collides(sibling) {
                        const d = dist(this.x, this.y, sibling.x, sibling.y);
                        return d < this.r / 2 + sibling.r;
                    }

                    excited() {
                        this.xOff += 0.005;
                        this.yOff += 0.005;
                    }
                }

                setup = () => {
                    createCanvas(windowWidth, windowHeight);
                    background(20);

                    for (let i = 0; i < 3; i++) {
                        balls.push(new Ball(36));
                    }

                    resetMouseLocation = () => mouseLocation = createVector(width / 2, height / 2);

                    target = createVector(width / 2, height / 2);
                    resetMouseLocation();
                };

                draw = () => {
                    background(20);

                    if (frameCount % 360 == 0) {
                        if (balls.length < width / 40) balls.push(new Ball());
                    }

                    for (const ball of balls) {
                        ball.update();

                        for (const sibling of balls) {
                            if (ball != sibling && ball.collides(sibling)) {
                                ball.excited();
                                sibling.excited();
                            }
                        }
                    }

                    if (mouseHasMoved) {
                        target = lastMouseMovement < frameCount - 100
                            ? createVector(width / 2, height / 2)
                            : createVector(mouseX, mouseY);
                    } else {
                        resetMouseLocation();
                    }
                    
                    distance = target.dist(mouseLocation);
                    target.sub(mouseLocation);
                    target.normalize();
                    const mappedDistance = map(distance, 100, 0, 6, 0.5);
                    target.mult(mappedDistance);
                    mouseLocation.add(target);
                };

                mouseMoved = () => {
                    mouseHasMoved = true;
                    lastMouseMovement = frameCount;
                };
            }
            ,
            // Perlin terrain generation with mouse movement
            () => {
                let cols, rows;
                let scale = 15;

                const terrain = [];

                let flying = 0;
                const noisiness = 0.05;

                let camXOff = 0;

                setup = () => {
                    createCanvas(windowWidth, windowHeight, WEBGL);
                    background(20);
                    frameRate(24);
                    stroke(255);
                    strokeWeight(0.5);
                    noFill();

                    cols = windowWidth / scale;
                    rows = windowHeight / scale;
                };

                draw = () => {
                    flying -= noisiness;
                    let yOff = 0;
                    for (let x = 0; x < rows; x++) {
                        terrain[x] = [];
                        let xOff = flying;
                        for (let y = 0; y < cols; y++) {
                            terrain[x][y] = map(noise(xOff, yOff), 0, 1, -100, 100);
                            xOff += noisiness;
                        }
                        yOff += noisiness;
                    }

                    background(20);

                    rotateX(PI / 3 + camXOff);
                    translate(-width / 2, -height / 2);

                    for (let y = 0; y < rows - 1; y++) {
                        beginShape(TRIANGLE_STRIP);
                        for (let x = 0; x < cols; x++) {
                            vertex(x * scale, y * scale, terrain[y][x]);
                        }
                        endShape();
                    }
                };

                mouseMoved = () => {
                    camXOff = map(mouseY, 0, height, -0.5, 0.5);
                };
            }
        ];
        
        windowResized = () => resizeCanvas(windowWidth, windowHeight);

        sketches[Math.floor(Math.random() * sketches.length)]();

    </script>
</body>
</html>