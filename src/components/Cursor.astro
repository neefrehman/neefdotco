<div class="cursor-presence-container"></div>

<div class="cursor-container hide">
  <div class="cursor">
    <div class="cursor-contents"></div>
  </div>
  <div class="cursor-inner"></div>
</div>

<style>
  .cursor-presence-container {
    opacity: 0.75;
  }

  .cursor-container {
    --cursor-radius: 1rem;
    --cursor-scale: 1;
    --cursor-inner-scale: 0;
    --cursor-contents-scale: 0;
    --cursor-background-color: var(--primary-color-mid);
    --cursor-inner-background-color: var(--background-color);
    --cursor-border-radius: 100%;
    --cursor-up: 0rem;
    --cursor-down: 0rem;
    --cursor-left: 0rem;
    --cursor-right: 0rem;

    position: fixed;
    pointer-events: none;
    z-index: -1;
    top: calc(
      (var(--cursor-radius) * -1) + ((var(--cursor-down) - var(--cursor-up)) * var(--cursor-scale))
    );
    left: calc(
      (var(--cursor-radius) * -1) +
        ((var(--cursor-right) - var(--cursor-left)) * var(--cursor-scale))
    );
    transition:
      translate 70ms,
      top 430ms cubic-bezier(1, 0.1, 0.1, 1),
      left 430ms cubic-bezier(1, 0.1, 0.1, 1);

    @media (ponter: coarse) {
      display: none;
    }

    .cursor,
    .cursor-inner {
      position: fixed;
      border-radius: var(--cursor-border-radius);
      width: calc(var(--cursor-radius) * 2);
      height: calc(var(--cursor-radius) * 2);
    }
  
    .cursor {
      overflow: hidden;
      background-color: var(--cursor-background-color);
      scale: var(--cursor-scale);
      transition:
        scale 430ms cubic-bezier(1, 0.1, 0.1, 1),
        background-color 200ms ease-in-out,
        border-radius 720ms ease;
    }
  
    .cursor-inner {
      background-color: var(--cursor-inner-background-color);
      scale: var(--cursor-inner-scale);
      transition:
        scale 780ms cubic-bezier(1, 0.1, 0.1, 1) 220ms,
        background-color 200ms ease-in-out,
        border-radius 430ms cubic-bezier(1, 0.1, 0.1, 1);
    }
  
    .cursor-contents {
      font-size: 0.8em;
      font-weight: bold;
      display: block;
      position: absolute;
      top: 50%;
      left: 50%;
      translate: -50% -50%;
      scale: var(--cursor-contents-scale);
      transition:
        translate 720ms ease,
        scale 720ms ease;
    }

    &.small {
      --cursor-scale: 0.5;
    }
    &.large {
      --cursor-scale: 2.5;
    }
    &.x-large {
      --cursor-scale: 3.5;
    }
    &.xx-large {
      --cursor-scale: 5;
    }
    &.xxx-large {
      --cursor-scale: 6;
    }
  
    &.hide {
      --cursor-scale: 0;
      --cursor-inner-scale: 0;
      --cursor-contents-scale: 0;
    }
  
    &.square {
      --cursor-border-radius: 10%;
    }
  
    &.has-contents {
      --cursor-contents-scale: 1;
    }
  
    &.contents-small-chars .cursor-contents {
      font-weight: normal;
      font-size: 2.2em;
      top: 52%;
    }
  
    &.up {
      --cursor-up: 1.2em;
    }
    &.down {
      --cursor-down: 1.2em;
    }
    &.left {
      --cursor-left: 1.2em;
    }
    &.right {
      --cursor-right: 1.2em;
    }
  
    &.in-gravity-well {
      /* Slower movement due to gravity */
      transition: translate 200ms ease-out;

      .cursor {
        /* Slower growth in size to show off effect */
        transition: scale 430ms ease;
      }

      &.small {
        --cursor-scale: 7;
      }
    }
  
    &.transition {
      --cursor-scale: 1.33;
      --cursor-inner-scale: 1.35;
      --cursor-contents-scale: 0;
      --cursor-inner-background-color: var(--background-color);
    }
  }
</style>

<script>
  import { throttle } from "utils/throttle";
  import { getDistance } from "utils/math/getDistance";
  import { lerpVector } from "utils/math/lerp";
  import { mapToRange } from "utils/math/maptoRange";

  if (matchMedia("(pointer:fine)").matches) {
    const cursor = document.querySelector<HTMLDivElement>("div.cursor-container");
    const cursorContents = document.querySelector<HTMLDivElement>(".cursor-contents");

    const gravityWell = document.querySelector<HTMLDivElement>("[data-gravity-well=true]");

    const handleCursorMove = ([mouseX, mouseY]: [number, number]) => {
      cursor.style.translate = `${mouseX}px ${mouseY}px`;
    };

    const handleCursorMoveWithGravityWell = ([mouseX, mouseY]: [number, number]) => {
      const largestViewPortSize = Math.max(window.innerWidth, window.innerHeight);
      const strongPullThreshold = largestViewPortSize / 4;
      const weakPullThreshold = strongPullThreshold + 50;

      const wellCenterX = gravityWell.offsetLeft + gravityWell.offsetWidth / 2;
      const wellCenterY = gravityWell.offsetTop + gravityWell.offsetHeight / 2;

      const distanceToWell = getDistance([wellCenterX, wellCenterY], [mouseX, mouseY]);

      if (distanceToWell > weakPullThreshold || !gravityWell.dataset.isActive) {
        cursor.classList.remove("in-gravity-well", "xxx-large");
        handleCursorMove([mouseX, mouseY]);
        if (gravityWell.dataset.cursorContentsInWell) {
          cursor.classList.remove("has-contents");
          cursorContents.innerText = "";
        }
        return;
      }

      if (distanceToWell > strongPullThreshold && !cursor.classList.contains("in-gravity-well")) {
        const [x, y] = lerpVector(
          [mouseX, mouseY],
          [wellCenterX, wellCenterY],
          mapToRange(10 + weakPullThreshold - distanceToWell, 0, largestViewPortSize, 0, 2)
        );
        cursor.style.translate = `${x}px ${y}px`;
      } else {
        cursor.classList.add("in-gravity-well", "xxx-large");
        const [x, y] = lerpVector(
          [wellCenterX, wellCenterY],
          [mouseX, mouseY],
          mapToRange(distanceToWell, 0, largestViewPortSize, 0, 0.33)
        );
        cursor.style.translate = `${x}px ${y}px`;
        if (gravityWell.dataset.cursorContentsInWell) {
          cursor.classList.add("has-contents");
          cursorContents.innerText = gravityWell.dataset.cursorContentsInWell;
        }
      }
    };

    document.addEventListener(
      "mousemove",
      throttle((e: MouseEvent) => {
        cursor.classList.remove("hide");
        !!gravityWell
          ? handleCursorMoveWithGravityWell([e.clientX, e.clientY])
          : handleCursorMove([e.clientX, e.clientY]);
      }, 30) // ~33fps
    );

    document.addEventListener("mousedown", () => cursor.classList.add("small"));
    document.addEventListener("mouseup", () => cursor.classList.remove("small"));

    const interactiveElements = document.querySelectorAll<HTMLAnchorElement>("a, button");
    const cursorColorElements = document.querySelectorAll<HTMLElement>("[data-cursor-color]");
    const cursorSizeElements = document.querySelectorAll<HTMLElement>("[data-cursor-size]");
    const cursorMoveElements = document.querySelectorAll<HTMLElement>("[data-cursor-move]");
    const cursorShapeElements = document.querySelectorAll<HTMLElement>("[data-cursor-shape]");
    const cursorContentsElements = document.querySelectorAll<HTMLElement>("[data-cursor-contents]");
    const cursorRegrowElements = document.querySelectorAll<HTMLElement>(
      "[data-cursor-regrow=true]"
    );

    interactiveElements.forEach(link => {
      link.addEventListener("mouseenter", () => cursor.classList.add("large"));
      link.addEventListener("mouseleave", () => cursor.classList.remove("large"));
    });

    cursorMoveElements.forEach(el => {
      el.addEventListener("mouseenter", () => cursor.classList.add(el.dataset.cursorMove));
      el.addEventListener("mouseleave", () => cursor.classList.remove(el.dataset.cursorMove));
    });

    cursorShapeElements.forEach(el => {
      el.addEventListener("mouseenter", () => cursor.classList.add(el.dataset.cursorShape));
      el.addEventListener("mouseleave", () => cursor.classList.remove(el.dataset.cursorShape));
    });

    cursorSizeElements.forEach(el => {
      el.addEventListener("mouseenter", () => cursor.classList.add(el.dataset.cursorSize));
      el.addEventListener("mouseleave", () => cursor.classList.remove(el.dataset.cursorSize));
    });

    cursorContentsElements.forEach(el => {
      el.addEventListener("mouseenter", () => {
        cursor.classList.add("has-contents");
        /* annoyingly some characters, like +/-, aren't quite the right size in fleuron */
        if (["+", "-", "–", "—"].includes(el.dataset.cursorContents))
          cursor.classList.add("contents-small-chars");
        cursorContents.innerText = el.dataset.cursorContents;
      });
      el.addEventListener("mouseleave", () => {
        cursor.classList.remove("has-contents", "contents-small-chars");
        cursorContents.innerText = "";
      });
      // some of these elements may change their data-cursor-contents attribute on click
      el.addEventListener("click", () => {
        setTimeout(() => (cursorContents.innerText = el.dataset.cursorContents), 10);
      });
    });

    cursorColorElements.forEach(el => {
      el.addEventListener("mouseenter", () => {
        cursor.style.setProperty("--cursor-background-color", el.dataset.cursorColor);
      });
      el.addEventListener("mouseleave", () =>
        cursor.style.setProperty("--cursor-background-color", null)
      );
    });

    cursorRegrowElements.forEach(el => {
      el.addEventListener("click", () => {
        if (!cursor.classList.contains(el.dataset.cursorSize)) return;
        cursor.classList.remove(el.dataset.cursorSize, "large");
        const cursorReset = setTimeout(() => cursor.classList.add(el.dataset.cursorSize), 1000);
        el.addEventListener("click", () => clearTimeout(cursorReset), { once: true });
        el.addEventListener(
          "mouseleave",
          () => {
            clearTimeout(cursorReset);
            cursor.classList.remove(el.dataset.cursorSize, "large");
          },
          { once: true }
        );
      });
    });

    const page = window.location.pathname.replace("/", "") || "index"
    const socket = new WebSocket(`${import.meta.env.PUBLIC_SOCKET_URL}/parties/main/${page}`);
    const cursorBlueprint = cursor.cloneNode(true);
    const presenceContainer = document.querySelector(".cursor-presence-container");
    const cursorMap = new Map<string, HTMLDivElement>();

    const createCursorFromBlueprint = (id: string) => {
      const newCursor = cursorBlueprint.cloneNode(true);
      newCursor.id = id;
      presenceContainer.append(newCursor);
      cursorMap.set(id, newCursor);
      return newCursor;
    };

    socket.addEventListener("message", event => {
      const data = JSON.parse(event.data);
      switch (data.type) {
        case "JOIN":
          createCursorFromBlueprint(data.id);
        case "LEAVE":
          cursorMap.delete(data.id);
          const cursorToDelete = document.getElementById(data.id);
          cursorToDelete.classList.add("hide");
          setTimeout(() => document.getElementById(data.id).remove(), 500);
        case "UPDATE":
          // TODO: optimise mutations / reads
          // TODO: map between different screen sizes
          // TODO: gravity between nearby cursors (delauney triangulation for high-scale? on the server?)
          const cursorToUpdate = cursorMap.get(data.id) ?? createCursorFromBlueprint(data.id);
          cursorToUpdate.className = data.message.className;
          cursorToUpdate.querySelector<HTMLDivElement>(".cursor-contents").innerText = data.message.innerText;
          cursorToUpdate.style.cssText = data.message.style;
          cursorToUpdate.style.setProperty("--cursor-background-color", data.message.color);
      }
    });

    socket.addEventListener("open", () => {
      const cursorInnerWithComputedBackgroundColor = cursor.querySelector<HTMLDivElement>(".cursor")
      const cursorMutationObserver = new MutationObserver(throttle((list) => {
        console.log(list);
        socket.send(
          JSON.stringify({
            className: cursor.className,
            innerText: cursorContents.innerText,
            style: cursor.style.cssText,
            color: getComputedStyle(cursorInnerWithComputedBackgroundColor).backgroundColor
          })
        );
      }, 30)); // ~33fps

      cursorMutationObserver.observe(cursor, {
        childList: true,
        subtree: true,
        attributeFilter: ["innerText", "class", "style"],
      });
    }, { once: true })

    // TODO: break out into transition-specific script?
    const navLinks = document.querySelectorAll<HTMLAnchorElement>(
      "[data-triggers-nav-transition=true]"
    );

    navLinks.forEach(link => {
      if (!link.href) return;
      link.addEventListener("click", e => {
        // Preload the page first, so that the post-transition page load is as smooth as possible
        // method inspired by instant.page: https://github.com/instantpage/instant.page
        document.head.appendChild(Object.assign(
          document.createElement('link'), {
            rel: 'prefetch',
            href: link.href,
            fetchPriority: "high",
          })
        );

        const transitionElements = document.querySelectorAll("[data-transition-element=true]");
        let interval = 150;
        transitionElements.forEach((el, i) => {
          setTimeout(() => el.classList.remove("loaded"), interval * i);
          interval -= 5;
        });

        setTimeout(() => cursor.classList.add("transition"), 200);

        const transitionDuration = Math.min(1000 + transitionElements.length * 100, 1700);
        setTimeout(() => window.location.assign(link.href), transitionDuration);
        e.preventDefault();
      });
    });

    // We need to handle cases where the browser saves the post-exit-transition state in the
    // bfcache, and quickly have those elements appear again if so
    window.addEventListener("pageshow", e => {
      if (!e.persisted) return;
      const transitionElements = document.querySelectorAll("[data-transition-element=true]");
      transitionElements.forEach(el => el.classList.add("loaded"));
      cursor.classList.remove("transition");
    });
  }
</script>
