<div class="cursor-presence-container"></div>

<div class="cursor-container hide">
  <div class="cursor">
    <div class="cursor-contents"></div>
  </div>
  <div class="cursor-inner"></div>
</div>

<style>
  .cursor-presence-container {
    position: absolute;
    z-index: -5;
  }

  .cursor-container {
    --cursor-radius: 1rem;
    --cursor-scale: 1;
    --cursor-inner-scale: 0;
    --cursor-contents-scale: 0;
    --cursor-background-color: var(--primary-color-mid);
    --cursor-inner-background-color: var(--background-color);
    --cursor-border-radius: 100%;
    --cursor-up: 0rem;
    --cursor-down: 0rem;
    --cursor-left: 0rem;
    --cursor-right: 0rem;

    position: fixed;
    pointer-events: none;
    z-index: -1;
    top: calc(
      (var(--cursor-radius) * -1) + ((var(--cursor-down) - var(--cursor-up)) * var(--cursor-scale))
    );
    left: calc(
      (var(--cursor-radius) * -1) +
        ((var(--cursor-right) - var(--cursor-left)) * var(--cursor-scale))
    );
    transition:
      translate 70ms,
      top 430ms cubic-bezier(1, 0.1, 0.1, 1),
      left 430ms cubic-bezier(1, 0.1, 0.1, 1);

    @media (ponter: coarse) {
      display: none;
    }

    .cursor,
    .cursor-inner {
      position: fixed;
      border-radius: var(--cursor-border-radius);
      width: calc(var(--cursor-radius) * 2);
      height: calc(var(--cursor-radius) * 2);
    }
  
    .cursor {
      overflow: hidden;
      background-color: var(--cursor-background-color);
      scale: var(--cursor-scale);
      transition:
        scale 430ms cubic-bezier(1, 0.1, 0.1, 1),
        background-color 200ms ease-in-out,
        border-radius 720ms ease;
    }
  
    .cursor-inner {
      background-color: var(--cursor-inner-background-color);
      scale: var(--cursor-inner-scale);
      transition:
        scale 780ms cubic-bezier(1, 0.1, 0.1, 1) 220ms,
        background-color 200ms ease-in-out,
        border-radius 430ms cubic-bezier(1, 0.1, 0.1, 1);
    }
  
    .cursor-contents {
      font-size: 0.8em;
      font-weight: bold;
      display: block;
      position: absolute;
      top: 50%;
      left: 50%;
      translate: -50% -50%;
      scale: var(--cursor-contents-scale);
      transition:
        translate 720ms ease,
        scale 720ms ease;
    }

    &.small {
      --cursor-scale: 0.5;
    }
    &.large {
      --cursor-scale: 2.5;
    }
    &.x-large {
      --cursor-scale: 3.5;
    }
    &.xx-large {
      --cursor-scale: 5;
    }
    &.xxx-large {
      --cursor-scale: 6;
    }
  
    &.hide {
      --cursor-scale: 0;
      --cursor-inner-scale: 0;
      --cursor-contents-scale: 0;
    }
  
    &.square {
      --cursor-border-radius: 10%;
    }
  
    &.has-contents {
      --cursor-contents-scale: 1;
    }
  
    &.contents-small-chars .cursor-contents {
      font-weight: normal;
      font-size: 2.2em;
      top: 52%;
    }
  
    &.up {
      --cursor-up: 1.2em;
    }
    &.down {
      --cursor-down: 1.2em;
    }
    &.left {
      --cursor-left: 1.2em;
    }
    &.right {
      --cursor-right: 1.2em;
    }
  
    &.in-gravity-well {
      /* Slower movement due to gravity */
      transition: translate 200ms ease-out;

      .cursor {
        /* Slower growth in size to show off effect */
        transition: scale 430ms ease;
      }

      &.small {
        --cursor-scale: 7;
      }
    }
  
    &.transition {
      --cursor-scale: 1.33;
      --cursor-inner-scale: 1.35;
      --cursor-contents-scale: 0;
      --cursor-inner-background-color: var(--background-color);
    }
  }
</style>

<script>
  import { throttle } from "utils/throttle";
  import { getDistance } from "utils/math/getDistance";
  import { lerpVector } from "utils/math/lerp";
  import { mapToRange } from "utils/math/maptoRange";
import { parseCursorOutput, serializeCursorInput } from "utils/cursors";

  if (matchMedia("(pointer:fine)").matches) {
    const cursor = document.querySelector<HTMLDivElement>("div.cursor-container");
    const cursorContents = document.querySelector<HTMLDivElement>(".cursor-contents");

    const gravityWell = document.querySelector<HTMLDivElement>("[data-gravity-well=true]");

    const getCursorTranslateString = ([mouseX, mouseY]: [number, number]) => `${mouseX}px ${mouseY}px`;

    const handleCursorMove = ([mouseX, mouseY]: [number, number]) => {
      cursor.dataset.x = mouseX.toString(); // We also write to data attributes to make it
      cursor.dataset.y = mouseY.toString(); // easier to send raw co-ordinates over the socket
      cursor.style.translate = getCursorTranslateString([mouseX, mouseY]);
    };

    const handleCursorMoveWithGravityWell = ([mouseX, mouseY]: [number, number]) => {
      const largestViewPortSize = Math.max(window.innerWidth, window.innerHeight);
      const strongPullThreshold = largestViewPortSize / 4;
      const weakPullThreshold = strongPullThreshold + 50;

      const wellCenterX = gravityWell.offsetLeft + gravityWell.offsetWidth / 2;
      const wellCenterY = gravityWell.offsetTop + gravityWell.offsetHeight / 2;

      const distanceToWell = getDistance([wellCenterX, wellCenterY], [mouseX, mouseY]);

      if (distanceToWell > weakPullThreshold || !gravityWell.dataset.isActive) {
        cursor.classList.remove("in-gravity-well", "xxx-large");
        handleCursorMove([mouseX, mouseY]);
        if (gravityWell.dataset.cursorContentsInWell) {
          cursor.classList.remove("has-contents");
          cursorContents.innerText = "";
        }
        return;
      }

      if (distanceToWell > strongPullThreshold && !cursor.classList.contains("in-gravity-well")) {
        const [x, y] = lerpVector(
          [mouseX, mouseY],
          [wellCenterX, wellCenterY],
          mapToRange(10 + weakPullThreshold - distanceToWell, 0, largestViewPortSize, 0, 2)
        );
        handleCursorMove([x, y]);
      } else {
        cursor.classList.add("in-gravity-well", "xxx-large");
        const [x, y] = lerpVector(
          [wellCenterX, wellCenterY],
          [mouseX, mouseY],
          mapToRange(distanceToWell, 0, largestViewPortSize, 0, 0.33)
        );
        handleCursorMove([x, y]);
        if (gravityWell.dataset.cursorContentsInWell) {
          cursor.classList.add("has-contents");
          cursorContents.innerText = gravityWell.dataset.cursorContentsInWell;
        }
      }
    };

    document.addEventListener(
      "mousemove",
      throttle((e: MouseEvent) => {
        cursor.classList.remove("hide");
        !!gravityWell
          ? handleCursorMoveWithGravityWell([e.clientX, e.clientY])
          : handleCursorMove([e.clientX, e.clientY]);
      }, 30) // ~33fps
    );

    document.addEventListener("mousedown", () => cursor.classList.add("small"));
    document.addEventListener("mouseup", () => cursor.classList.remove("small"));

    const interactiveElements = document.querySelectorAll<HTMLAnchorElement>("a, button");
    const cursorColorElements = document.querySelectorAll<HTMLElement>("[data-cursor-color]");
    const cursorSizeElements = document.querySelectorAll<HTMLElement>("[data-cursor-size]");
    const cursorMoveElements = document.querySelectorAll<HTMLElement>("[data-cursor-move]");
    const cursorShapeElements = document.querySelectorAll<HTMLElement>("[data-cursor-shape]");
    const cursorContentsElements = document.querySelectorAll<HTMLElement>("[data-cursor-contents]");
    const cursorRegrowElements = document.querySelectorAll<HTMLElement>(
      "[data-cursor-regrow=true]"
    );

    interactiveElements.forEach(link => {
      link.addEventListener("mouseenter", () => cursor.classList.add("large"));
      link.addEventListener("mouseleave", () => cursor.classList.remove("large"));
    });

    cursorMoveElements.forEach(el => {
      el.addEventListener("mouseenter", () => cursor.classList.add(el.dataset.cursorMove));
      el.addEventListener("mouseleave", () => cursor.classList.remove(el.dataset.cursorMove));
    });

    cursorShapeElements.forEach(el => {
      el.addEventListener("mouseenter", () => cursor.classList.add(el.dataset.cursorShape));
      el.addEventListener("mouseleave", () => cursor.classList.remove(el.dataset.cursorShape));
    });

    cursorSizeElements.forEach(el => {
      el.addEventListener("mouseenter", () => cursor.classList.add(el.dataset.cursorSize));
      el.addEventListener("mouseleave", () => cursor.classList.remove(el.dataset.cursorSize));
    });

    cursorContentsElements.forEach(el => {
      el.addEventListener("mouseenter", () => {
        cursor.classList.add("has-contents");
        /* annoyingly some characters, like +/-, aren't quite the right size in fleuron */
        if (["+", "-", "–", "—"].includes(el.dataset.cursorContents))
          cursor.classList.add("contents-small-chars");
        cursorContents.innerText = el.dataset.cursorContents;
      });
      el.addEventListener("mouseleave", () => {
        cursor.classList.remove("has-contents", "contents-small-chars");
        cursorContents.innerText = "";
      });
      // some of these elements may change their data-cursor-contents attribute on click
      el.addEventListener("click", () => {
        setTimeout(() => (cursorContents.innerText = el.dataset.cursorContents), 10);
      });
    });

    cursorColorElements.forEach(el => {
      el.addEventListener("mouseenter", () => {
        cursor.style.setProperty("--cursor-background-color", el.dataset.cursorColor);
      });
      el.addEventListener("mouseleave", () =>
        cursor.style.setProperty("--cursor-background-color", null)
      );
    });

    cursorRegrowElements.forEach(el => {
      el.addEventListener("click", () => {
        if (!cursor.classList.contains(el.dataset.cursorSize)) return;
        cursor.classList.remove(el.dataset.cursorSize, "large");
        const cursorReset = setTimeout(() => cursor.classList.add(el.dataset.cursorSize), 1000);
        el.addEventListener("click", () => clearTimeout(cursorReset), { once: true });
        el.addEventListener(
          "mouseleave",
          () => {
            clearTimeout(cursorReset);
            cursor.classList.remove(el.dataset.cursorSize, "large");
          },
          { once: true }
        );
      });
    });

    const connectToCursorSocket = () => {
      const page = window.location.pathname.replace("/", "") || "index"
      const socket = new WebSocket(`${import.meta.env.PUBLIC_SOCKET_URL}/parties/main/${page}`);
  
      const cursorBlueprint = cursor.cloneNode(true);
      const presenceContainer = document.querySelector(".cursor-presence-container");
      const cursorMap = new Map<string, { cursor: HTMLDivElement, cursorContents: HTMLDivElement }>();
  
      const createCursorFromBlueprint = (id: string) => {
        const newCursor = cursorBlueprint.cloneNode(true);
        newCursor.id = id;
        presenceContainer.append(newCursor);
        const cursorContents = newCursor.querySelector<HTMLDivElement>(".cursor-contents")
        const cursorObject = { cursor: newCursor, cursorContents }
        cursorMap.set(id, cursorObject);
        return cursorObject;
      };
  
      const removeCursor = (id: string) => {
        cursorMap.delete(id);
        const cursorToDelete = document.getElementById(id);
        cursorToDelete.classList.add("hide")
        setTimeout(() => document.getElementById(id).remove(), 500);
      }
  
      socket.addEventListener("message", event => {
        const data = parseCursorOutput(event.data);
        switch (data.type) {
          case "JOIN":
            createCursorFromBlueprint(data.id);
            break;
          case "LEAVE":
            removeCursor(data.id)
            break;
          case "UPDATE":
            // TODO: optimise mutations / reads
            // TODO: gravity between nearby cursors (delauney triangulation for high-scale? on the server?)
            // TODO: handle delayed colour/text changes due to throttling and getComputedStyle with transition, maybe implement and listen to data attr changes only?
            // TODO: update scroll when the user scrolls, instead of one mouse move (and more generally, fractional updates)
            // TODO: rudimentary chat?
            const { id, message: { className, color, coords: [x, y], innerText } } = data
            const { cursor: cursorToUpdate, cursorContents } = cursorMap.get(id) ?? createCursorFromBlueprint(id);
            cursorContents.innerText = innerText;
            cursorToUpdate.style.translate = getCursorTranslateString([x, y - window.scrollY]);
            cursorToUpdate.style.setProperty("--cursor-background-color", color);
            cursorToUpdate.className = className;
            break;
        }
      });
  
      let connectInterval: NodeJS.Timeout;
      socket.addEventListener("open", () => {
        clearInterval(connectInterval)
        const innerCursorWithComputedBackgroundColor = cursor.querySelector<HTMLDivElement>(".cursor");
  
        const cursorMutationObserver = new MutationObserver(throttle(() => {
          socket.send(
            serializeCursorInput({
              className: cursor.className,
              innerText: cursorContents.innerText,
              style: cursor.style.cssText,
              color: getComputedStyle(innerCursorWithComputedBackgroundColor).backgroundColor,
              coords: [parseInt(cursor.dataset.x), parseInt(cursor.dataset.y)],
              scrollY: window.scrollY,
            })
          );
        }, 30)); // ~33fps
  
        cursorMutationObserver.observe(cursor, {
          childList: true,
          subtree: true,
          attributeFilter: ["innerText", "class", "style"],
        });
  
        socket.addEventListener("close", () => {
          cursorMutationObserver.disconnect()
          cursorMap.forEach((_, id) => removeCursor(id))
          connectInterval = setInterval(connectToCursorSocket, 1000);
          setTimeout(() => clearInterval(connectInterval), 5000);
        }, { once: true });
      });
    };
    connectToCursorSocket();

    // TODO: break out into transition-specific script?
    const navLinks = document.querySelectorAll<HTMLAnchorElement>(
      "[data-triggers-nav-transition=true]"
    );

    navLinks.forEach(link => {
      if (!link.href) return;
      link.addEventListener("click", e => {
        // Preload the page first, so that the post-transition page load is as smooth as possible
        // method inspired by instant.page: https://github.com/instantpage/instant.page
        document.head.appendChild(Object.assign(
          document.createElement('link'), {
            rel: 'prefetch',
            href: link.href,
            fetchPriority: "high",
          })
        );

        const transitionElements = document.querySelectorAll("[data-transition-element=true]");
        let interval = 150;
        transitionElements.forEach((el, i) => {
          setTimeout(() => el.classList.remove("loaded"), interval * i);
          interval -= 5;
        });

        setTimeout(() => cursor.classList.add("transition"), 200);

        const transitionDuration = Math.min(1000 + transitionElements.length * 100, 1700);
        setTimeout(() => window.location.assign(link.href), transitionDuration);
        e.preventDefault();
      });
    });

    // We need to handle cases where the browser saves the post-exit-transition state in the
    // bfcache, and quickly have those elements appear again if so
    window.addEventListener("pageshow", e => {
      if (!e.persisted) return;
      const transitionElements = document.querySelectorAll("[data-transition-element=true]");
      transitionElements.forEach(el => el.classList.add("loaded"));
      cursor.classList.remove("transition");
    });
  }
</script>
