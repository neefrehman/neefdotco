---
interface Props {
  is404?: boolean;
}

const { is404 } = Astro.props;

const SKILLS = [
  // Outer circle
  "React",
  "Node.js",
  "Accessibility",
  "AWS",
  "CI/CD",
  "Next.js",
  "Animation",
  "Cypress",
  "Documentation",
  "Data visualisation",
  "Jest",
  "API Design",
  "D3.js",
  "WebGL",
  "Product Engineering",
  "Agile",
  "Technical writing",
  "Interaction design",
  "Python",
  "Technical architecture",
  "GLSL",
  "Creative coding",
  "Observability",
  "CSS",
  "Image processing",
  "Unity",
  "Custom tooling",
  "Vercel",
  "Prioritisation",
  "Technical art",
  // Middle circle
  "Prototyping",
  "UI Engineering",
  "Postgres",
  "Shell scripting",
  "GCP",
  "Github actions",
  "Three.js",
  "SQL",
  "Shaders",
  "Backlog refinement",
  "Education",
  "WCAG",
  "Serverless",
  "React Three Fiber",
  "Maths",
  "Public speaking",
  "Code review",
  "Mentoring",
  "Workshops",
  "Automated testing",
  // Inner circle
  "Terraform",
  "Typescript",
  "Docker",
  "GraphQL",
  "Figma",
  "Tailwind",
  "MongoDB",
  "Infrastructure",
  "Build tooling",
  "Graphics",
] as const satisfies { length: 60 };

/*
  Circumference = 2 * PI * r, so doubling the radius also doubles the circumference, i.e. each
  concentric ring should increase in word count by the number of words of the smallest ring.
*/
const OUTER_CIRCLE_WORD_COUNT = 30;
const MIDDLE_CIRCLE_WORD_COUNT = 20;
const INNER_CIRCLE_WORD_COUNT = 10;

const words = is404 ? Array<string>(60).fill("404") : SKILLS;

const spliceableWords = words as string[];
const OUTER_CIRCLE = spliceableWords.splice(0, OUTER_CIRCLE_WORD_COUNT);
const MIDDLE_CIRCLE = spliceableWords.splice(0, MIDDLE_CIRCLE_WORD_COUNT);
const INNER_CIRCLE = spliceableWords.splice(0, INNER_CIRCLE_WORD_COUNT);
---

{
  !is404 && (
    <ul class="screen-reader-only" aria-hidden={is404 ? "true" : "false"}>
      {SKILLS.map(skill => (
        <li>{skill}</li>
      ))}
    </ul>
  )
}

<div class="system" data-gravity-well="true" role="presentation">
  <div class="ring" style="--ring-index: 3" data-transition-element="true">
    <ul style={`--word-count: ${OUTER_CIRCLE.length}`}>
      {OUTER_CIRCLE.map((skill, i) => <li style={`--index: ${i}`}>{skill}</li>)}
    </ul>
  </div>

  <div class="ring" style="--ring-index: 2" data-transition-element="true">
    <ul style={`--word-count: ${MIDDLE_CIRCLE.length}`}>
      {MIDDLE_CIRCLE.map((skill, i) => <li style={`--index: ${i}`}>{skill}</li>)}
    </ul>
  </div>

  <div class="ring" style="--ring-index: 1" data-transition-element="true">
    <ul style={`--word-count: ${INNER_CIRCLE.length}`}>
      {INNER_CIRCLE.map((skill, i) => <li style={`--index: ${i}`}>{skill}</li>)}
    </ul>
  </div>
</div>

<style>
  div.system {
    position: fixed;
    z-index: -1;
    bottom: 13vh;
    right: 8vw;
    transform: rotate(-10deg);
  }

  /* Lower opacity and move further from the top on shorter devices, to avoid clashes with page content */
  @media (max-height: 700px) and (max-width: 700px) {
    div.system {
      bottom: 8vh;
      right: 4vw;
      opacity: 0.5;
    }
  }

  div.system .ring {
    opacity: 1;
    top: 0px;
    position: relative;
    transform-style: preserve-3d;
    transition: transform 1000ms ease, opacity 400ms ease,
      top 1000ms cubic-bezier(0, 0.9, 0.1, 1), rotate calc(500ms * var(--ring-index)) ease;
  }

  div.system .ring:not(.loaded) {
    top: 20vh;
    opacity: 0;
    transition: transform 1000ms ease, opacity 400ms ease,
      top 500ms cubic-bezier(0.9, 0, 0.4, 1);
  }

  div.system ul {
    position: relative;
    transform-style: preserve-3d;
    animation: three-dimensions-circle 420s linear infinite;
  }

  div.system ul > li {
    position: absolute;
    top: 50%;
    left: 50%;
    padding: 0 4px;
    line-height: 1.3;
    width: max-content;
    background-color: var(--link-background-color);
    color: var(--text-color);
    --r: clamp(var(--ring-index) * 250px, var(--ring-index) * 25vw, var(--ring-index) * 600px);
    --a: calc(var(--index) * (360 / var(--word-count)) * 1deg);
    transform: translateX(-50%) rotateZ(var(--a)) translateY(var(--r)) rotateX(90deg);
  }

  @media not (pointer: coarse) {
    div.system:has(:hover) {
      --rotateZ: 5deg;
    }

    div.system:has(:active) {
      --rotateZ: 10deg;
    }

    div.system .ring:nth-child(odd) {
      transform: rotateZ(var(--rotateZ, 0deg));
    }

    div.system .ring:nth-child(even) {
      transform: rotateZ(calc(var(--rotateZ, 0deg) * -1));
    }

    div.system ul > li:hover {
      background-color: var(--opposite-mode-background);
      color: var(--background-color);
    }
  }

  @keyframes three-dimensions-circle {
    0% {
      transform: rotateX(-100deg) rotate(0);
    }
    100% {
      transform: rotateX(-100deg) rotate(-360deg);
    }
  }
</style>

<script>
  const rings = document.querySelectorAll<HTMLElement>(".system .ring");
  rings.forEach((ring, i) => {
    setTimeout(() => ring.classList.add("loaded"), 500 + i * 300);
  });

  // only pull cursor once rings have completed their transitions
  const system = document.querySelector<HTMLElement>(".system");
  setTimeout(() => (system.dataset.isActive = "true"), 600 + rings.length * 300);

  /** The setTimeout doesnt seem to work, and setting a delay in CSS clashed with other transform transitions */
  if ("ontouchstart" in document.documentElement && "DeviceOrientationEvent" in window) {
    interface iOSDeviceOrientationEvent extends DeviceOrientationEvent {
      requestPermission?: () => Promise<"granted" | "forbidden">;
    }
    const DOE = DeviceOrientationEvent as unknown as iOSDeviceOrientationEvent;

    let hasOrientationListener = false;
    const addOrientationListener = () => {
      if (hasOrientationListener) return;
      window.addEventListener("deviceorientation", e => {
        hasOrientationListener = true;
        const tilt = window.innerHeight > window.innerWidth ? e.gamma : e.beta;
        rings.forEach(ring => (ring.style.rotate = `${tilt}deg`));
      });
    };

    const orbiters = document.querySelectorAll<HTMLElement>(".system li");
    orbiters.forEach(object => {
      object.addEventListener("click", () => {
        // For iOS devices that need permission, we request it and only add the event listener
        // when granted. This is a noop if we already have permissions.
        if ("requestPermission" in DOE) {
          DOE.requestPermission()
            .then(state => {
              if (state === "granted") addOrientationListener();
            })
            .catch();
        }
        // for other devices, and for already granted iOS devices, we add the listener
        addOrientationListener();
      });
    });
  }
</script>
