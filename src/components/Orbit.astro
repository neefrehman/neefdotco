---
import { shuffle } from "utils/math/shuffle";

interface Props {
  is404?: boolean;
}

const { is404 } = Astro.props;

const SKILLS = [
  "React",
  "Typescript",
  "Node.js",
  "Terraform",
  "AWS",
  "GCP",
  "CI/CD",
  "Jest",
  "Next.js",
  "Cypress",
  "Documentation",
  "Accessibility",
  "Animation",
  "Data visualisation",
  "WebGL",
  "Technical writing",
  "API Design",
  "GraphQL",
  "D3.js",
  "GLSL",
  "Tailwind",
  "Technical art",
  "Python",
  "Creative coding",
  "Interaction design",
  "CSS",
  "Observability",
  "Unity",
  "Docker",
  "Technical architecture",
  "Serverless",
  "Prototyping",
  "Shaders",
  "Maths",
  "Product Engineering",
  "UI Engineering",
  "SQL",
  "Postgres",
  "MongoDB",
  "Shell scripting",
  "Github actions",
  "Mentoring",
  "Education",
  "Three.js",
  "React Three Fiber",
];

/*
  Circumference = 2 * PI * r, so doubling the radius also doubles the circumference, i.e. each
  concentric ring should increase in word count by the number of words of the smallest ring.
*/
const SMALLEST_CIRCLE_WORD_COUNT = 10;
const FIRST_CIRCLE_WORD_COUNT = 3 * SMALLEST_CIRCLE_WORD_COUNT;
const SECOND_CIRCLE_WORD_COUNT = 2 * SMALLEST_CIRCLE_WORD_COUNT;
const THIRD_CIRCLE_WORD_COUNT = 1 * SMALLEST_CIRCLE_WORD_COUNT; // TODO: no long string here?

const totalWordCount =
  FIRST_CIRCLE_WORD_COUNT + SECOND_CIRCLE_WORD_COUNT + THIRD_CIRCLE_WORD_COUNT;

/** Duplicates skills until circles are full, and ensures that no siblings have the same text */
const getSkillstoRender = () => {
  let skills = shuffle([SKILLS, SKILLS].flat().slice(0, totalWordCount));
  const hasIdenticalSiblings = function (sides: string[]) {
    for (var i = 0; i < sides.length - 1; i++) {
      if (sides[i][0] === sides[i + 1][0]) return false;
    }
    return true;
  };
  while (!hasIdenticalSiblings(skills)) skills = shuffle(skills);
  return skills;
};

const words = is404 ? Array<string>(100).fill("404") : getSkillstoRender();

const FIRST_CIRCLE = words.splice(0, FIRST_CIRCLE_WORD_COUNT);
const SECOND_CIRCLE = words.splice(0, SECOND_CIRCLE_WORD_COUNT);
const THIRD_CIRCLE = words.splice(0, THIRD_CIRCLE_WORD_COUNT);
---

{
  !is404 && (
    <ul class="screen-reader-only" aria-hidden={is404 ? "true" : "false"}>
      {SKILLS.map(skill => (
        <li>{skill}</li>
      ))}
    </ul>
  )
}

<div class="system" data-gravity-well="true" aria-role="presentation">
  <section style="--ring-index: 3">
    <ul style={`--word-count: ${FIRST_CIRCLE.length}`}>
      {FIRST_CIRCLE.map((skill, i) => <li style={`--index: ${i}`}>{skill}</li>)}
    </ul>
  </section>

  <section style="--ring-index: 2">
    <ul style={`--word-count: ${SECOND_CIRCLE.length}`}>
      {SECOND_CIRCLE.map((skill, i) => <li style={`--index: ${i}`}>{skill}</li>)}
    </ul>
  </section>

  <section style="--ring-index: 1">
    <ul style={`--word-count: ${THIRD_CIRCLE.length}`}>
      {THIRD_CIRCLE.map((skill, i) => <li style={`--index: ${i}`}>{skill}</li>)}
    </ul>
  </section>
</div>

<style>
  div.system {
    position: fixed;
    z-index: -1;
    bottom: 13vh;
    right: 8vw;
    transform: rotate(-10deg);
  }

  /* Lower opacity and move further from the top on shorter devices, to avoid clashes with page content */
  @media (max-height: 700px) and (max-width: 700px) {
    div.system {
      bottom: 8vh;
      right: 4vw;
      opacity: 0.5;
    }
  }

  div.system section {
    opacity: 1;
    top: 0px;
    position: relative;
    transform-style: preserve-3d;
    transition: transform 1000ms ease, opacity 400ms ease,
      top 1000ms cubic-bezier(0, 0.9, 0.1, 1);
  }

  div.system section:not(.loaded) {
    top: 20vh;
    opacity: 0;
    transition: transform 1000ms ease, opacity 400ms ease,
      top 500ms cubic-bezier(0.9, 0, 0.6, 1);
  }

  div.system:has(:hover) {
    --rotateZ: 5deg;
  }

  div.system:has(:active) {
    --rotateZ: 10deg;
  }

  div.system section:nth-child(odd) {
    transform: rotateZ(var(--rotateZ, 0deg));
  }

  div.system section:nth-child(even) {
    transform: rotateZ(calc(var(--rotateZ, 0deg) * -1));
  }

  @keyframes three-dimensions-circle {
    0% {
      transform: rotateX(-100deg) rotate(0);
    }
    100% {
      transform: rotateX(-100deg) rotate(-360deg);
    }
  }

  div.system ul {
    font-size: 1em;
    font-family: sans-serif;
    position: relative;
    list-style: none;
    transform-style: preserve-3d;
    animation: three-dimensions-circle 420s linear infinite;
  }

  div.system ul > li {
    position: absolute;
    top: 50%;
    left: 50%;
    padding: 0 2px;
    width: max-content;
    background-color: var(--link-background-color);
    color: var(--text-color);
    --r: clamp(var(--ring-index) * 250px, var(--ring-index) * 25vw, var(--ring-index) * 600px);
    --a: calc(var(--index) * (360 / var(--word-count)) * 1deg);
    transform: translateX(-50%) rotateZ(var(--a)) translateY(var(--r)) rotateX(90deg);
  }

  div.system ul > li:hover {
    background-color: var(--opposite-mode-background);
    color: var(--background-color);
  }
</style>

<script>
  const rings = document.querySelectorAll<HTMLElement>(".system section");
  rings.forEach((ring, i) => {
    setTimeout(() => ring.classList.add("loaded"), 600 + i * 300);
  });

  // only pull cursor once rings have completed their transitions
  const system = document.querySelector<HTMLElement>(".system");
  setTimeout(() => (system.dataset.isActive = "true"), 1000 + rings.length * 300);

  /** The setTimeout doesnt seem to work, and setting a delay in CSS clashed with other transform transitions */
  // if ("ontouchstart" in document.documentElement) {
  //   const tiltLogo = (tilt: number) => {
  //     const cappedTilt = Math.max(-20, Math.min(20, tilt * 0.5));
  //     rings.forEach((ring, i) => {
  //       setTimeout((ring.style.transform = `rotateZ(${cappedTilt}deg)`), 100);
  //     });
  //   };

  //   if ((DeviceOrientationEvent as any).requestPermission) {
  //     const ringObjects = document.querySelectorAll<HTMLElement>(".system li");
  //     ringObjects.forEach(object => {
  //       object.addEventListener("click", () => {
  //         (DeviceOrientationEvent as any)
  //           .requestPermission()
  //           .then(state => {
  //             if (state === "granted") {
  //               window.addEventListener("deviceorientation", e => {
  //                 tiltLogo(window.innerHeight > window.innerWidth ? e.gamma : e.beta);
  //               });
  //             }
  //           })
  //           .catch();
  //       });
  //     });

  //     window.addEventListener("deviceorientation", e => {
  //       tiltLogo(window.innerHeight > window.innerWidth ? e.gamma : e.beta);
  //     });
  //   }
  // }
</script>
